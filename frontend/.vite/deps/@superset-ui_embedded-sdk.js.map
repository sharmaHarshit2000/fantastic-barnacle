{
  "version": 3,
  "sources": ["../../node_modules/@superset-ui/embedded-sdk/src/const.ts", "../../node_modules/@superset-ui/switchboard/src/switchboard.ts", "../../node_modules/@superset-ui/switchboard/src/index.ts", "../../node_modules/jwt-decode/build/cjs/index.js", "../../node_modules/@superset-ui/embedded-sdk/src/guestTokenRefresh.ts", "../../node_modules/@superset-ui/embedded-sdk/src/index.ts"],
  "sourcesContent": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const IFRAME_COMMS_MESSAGE_TYPE = \"__embedded_comms__\";\nexport const DASHBOARD_UI_FILTER_CONFIG_URL_PARAM_KEY: { [index: string]: any } = {\n  visible: \"show_filters\",\n  expanded: \"expand_filters\",\n}\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport type Params = {\n  port: MessagePort;\n  name?: string;\n  debug?: boolean;\n};\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nenum Actions {\n  GET = 'get',\n  REPLY = 'reply',\n  EMIT = 'emit',\n  ERROR = 'error',\n}\n\ntype Method<A extends {}, R> = (args: A) => R | Promise<R>;\n\n// helper types/functions for making sure wires don't get crossed\n\ninterface Message {\n  switchboardAction: Actions;\n}\n\ninterface GetMessage<T = any> extends Message {\n  switchboardAction: Actions.GET;\n  method: string;\n  messageId: string;\n  args: T;\n}\n\nfunction isGet(message: Message): message is GetMessage {\n  return message.switchboardAction === Actions.GET;\n}\n\ninterface ReplyMessage<T = any> extends Message {\n  switchboardAction: Actions.REPLY;\n  messageId: string;\n  result: T;\n}\n\nfunction isReply(message: Message): message is ReplyMessage {\n  return message.switchboardAction === Actions.REPLY;\n}\n\ninterface EmitMessage<T = any> extends Message {\n  switchboardAction: Actions.EMIT;\n  method: string;\n  args: T;\n}\n\nfunction isEmit(message: Message): message is EmitMessage {\n  return message.switchboardAction === Actions.EMIT;\n}\n\ninterface ErrorMessage extends Message {\n  switchboardAction: Actions.ERROR;\n  messageId: string;\n  error: string;\n}\n\nfunction isError(message: Message): message is ErrorMessage {\n  return message.switchboardAction === Actions.ERROR;\n}\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n  port: MessagePort;\n\n  name = '';\n\n  methods: Record<string, Method<any, unknown>> = {};\n\n  // used to make unique ids\n  incrementor = 1;\n\n  debugMode: boolean;\n\n  private isInitialised: boolean;\n\n  constructor(params?: Params) {\n    if (!params) {\n      return;\n    }\n    this.init(params);\n  }\n\n  init(params: Params) {\n    if (this.isInitialised) {\n      this.logError('already initialized');\n      return;\n    }\n\n    const { port, name = 'switchboard', debug = false } = params;\n\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n\n    port.addEventListener('message', async event => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n\n    this.isInitialised = true;\n  }\n\n  private async getMethodResult({\n    messageId,\n    method,\n    args,\n  }: GetMessage): Promise<ReplyMessage | ErrorMessage> {\n    const executor = this.methods[method];\n    if (executor == null) {\n      return <ErrorMessage>{\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined`,\n      };\n    }\n    try {\n      const result = await executor(args);\n      return <ReplyMessage>{\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result,\n      };\n    } catch (err) {\n      this.logError(err);\n      return <ErrorMessage>{\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error`,\n      };\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod<A extends {}, R = any>(\n    methodName: string,\n    executor: Method<A, R>,\n  ) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonsense.\n   * @returns whatever is returned from the method\n   */\n  get<T = unknown>(method: string, args: unknown = undefined): Promise<T> {\n    return new Promise((resolve, reject) => {\n      if (!this.isInitialised) {\n        reject(new Error('Switchboard not initialised'));\n        return;\n      }\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event: MessageEvent) => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message)\n            ? message.error\n            : 'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message: GetMessage = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args,\n      };\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method: string, args: unknown = undefined) {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    const message: EmitMessage = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args,\n    };\n    this.port.postMessage(message);\n  }\n\n  start() {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    this.port.start();\n  }\n\n  private log(...args: unknown[]) {\n    if (this.debugMode) {\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n\n  private logError(...args: unknown[]) {\n    console.error(`[${this.name}]`, ...args);\n  }\n\n  private getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  }\n}\n\nexport default new Switchboard();\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport Switchboard from './switchboard';\n\nexport * from './switchboard';\nexport default Switchboard;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.jwtDecode = exports.InvalidTokenError = void 0;\nclass InvalidTokenError extends Error {\n}\nexports.InvalidTokenError = InvalidTokenError;\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nfunction jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\nexports.jwtDecode = jwtDecode;\n", "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { jwtDecode } from \"jwt-decode\";\n\nexport const REFRESH_TIMING_BUFFER_MS = 5000 // refresh guest token early to avoid failed superset requests\nexport const MIN_REFRESH_WAIT_MS = 10000 // avoid blasting requests as fast as the cpu can handle\nexport const DEFAULT_TOKEN_EXP_MS = 300000 // (5 min) used only when parsing guest token exp fails\n\n// when do we refresh the guest token?\nexport function getGuestTokenRefreshTiming(currentGuestToken: string) {\n  const parsedJwt = jwtDecode<Record<string, any>>(currentGuestToken);\n  // if exp is int, it is in seconds, but Date() takes milliseconds\n  const exp = new Date(/[^0-9\\.]/g.test(parsedJwt.exp) ? parsedJwt.exp : parseFloat(parsedJwt.exp) * 1000);\n  const isValidDate = exp.toString() !== 'Invalid Date';\n  const ttl = isValidDate ? Math.max(MIN_REFRESH_WAIT_MS, exp.getTime() - Date.now()) : DEFAULT_TOKEN_EXP_MS;\n  return ttl - REFRESH_TIMING_BUFFER_MS;\n}\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport {\n  DASHBOARD_UI_FILTER_CONFIG_URL_PARAM_KEY,\n  IFRAME_COMMS_MESSAGE_TYPE,\n} from './const';\n\n// We can swap this out for the actual switchboard package once it gets published\nimport { Switchboard } from '@superset-ui/switchboard';\nimport { getGuestTokenRefreshTiming } from './guestTokenRefresh';\n\n/**\n * The function to fetch a guest token from your Host App's backend server.\n * The Host App backend must supply an API endpoint\n * which returns a guest token with appropriate resource access.\n */\nexport type GuestTokenFetchFn = () => Promise<string>;\n\nexport type UiConfigType = {\n  hideTitle?: boolean;\n  hideTab?: boolean;\n  hideChartControls?: boolean;\n  emitDataMasks?: boolean;\n  filters?: {\n    [key: string]: boolean | undefined;\n    visible?: boolean;\n    expanded?: boolean;\n  };\n  urlParams?: {\n    [key: string]: any;\n  };\n};\n\nexport type EmbedDashboardParams = {\n  /** The id provided by the embed configuration UI in Superset */\n  id: string;\n  /** The domain where Superset can be located, with protocol, such as: https://superset.example.com */\n  supersetDomain: string;\n  /** The html element within which to mount the iframe */\n  mountPoint: HTMLElement;\n  /** A function to fetch a guest token from the Host App's backend server */\n  fetchGuestToken: GuestTokenFetchFn;\n  /** The dashboard UI config: hideTitle, hideTab, hideChartControls, filters.visible, filters.expanded **/\n  dashboardUiConfig?: UiConfigType;\n  /** Are we in debug mode? */\n  debug?: boolean;\n  /** The iframe title attribute */\n  iframeTitle?: string;\n  /** additional iframe sandbox attributes ex (allow-top-navigation, allow-popups-to-escape-sandbox) **/\n  iframeSandboxExtras?: string[];\n  /** force a specific refererPolicy to be used in the iframe request **/\n  referrerPolicy?: ReferrerPolicy;\n};\n\nexport type Size = {\n  width: number;\n  height: number;\n};\n\nexport type ObserveDataMaskCallbackFn = (\n  dataMask: Record<string, any> & {\n    crossFiltersChanged: boolean;\n    nativeFiltersChanged: boolean;\n  },\n) => void;\nexport type EmbeddedDashboard = {\n  getScrollSize: () => Promise<Size>;\n  unmount: () => void;\n  getDashboardPermalink: (anchor: string) => Promise<string>;\n  getActiveTabs: () => Promise<string[]>;\n  observeDataMask: (\n    callbackFn: ObserveDataMaskCallbackFn,\n  ) => void;\n  getDataMask: () => Record<string, any>;\n  setThemeConfig: (themeConfig: Record<string, any>) => void;\n};\n\n/**\n * Embeds a Superset dashboard into the page using an iframe.\n */\nexport async function embedDashboard({\n  id,\n  supersetDomain,\n  mountPoint,\n  fetchGuestToken,\n  dashboardUiConfig,\n  debug = false,\n  iframeTitle = 'Embedded Dashboard',\n  iframeSandboxExtras = [],\n  referrerPolicy,\n}: EmbedDashboardParams): Promise<EmbeddedDashboard> {\n  function log(...info: unknown[]) {\n    if (debug) {\n      console.debug(`[superset-embedded-sdk][dashboard ${id}]`, ...info);\n    }\n  }\n\n  log('embedding');\n\n  if (supersetDomain.endsWith('/')) {\n    supersetDomain = supersetDomain.slice(0, -1);\n  }\n\n  function calculateConfig() {\n    let configNumber = 0;\n    if (dashboardUiConfig) {\n      if (dashboardUiConfig.hideTitle) {\n        configNumber += 1;\n      }\n      if (dashboardUiConfig.hideTab) {\n        configNumber += 2;\n      }\n      if (dashboardUiConfig.hideChartControls) {\n        configNumber += 8;\n      }\n      if (dashboardUiConfig.emitDataMasks) {\n        configNumber += 16;\n      }\n    }\n    return configNumber;\n  }\n\n  async function mountIframe(): Promise<Switchboard> {\n    return new Promise(resolve => {\n      const iframe = document.createElement('iframe');\n      const dashboardConfigUrlParams = dashboardUiConfig\n        ? { uiConfig: `${calculateConfig()}` }\n        : undefined;\n      const filterConfig = dashboardUiConfig?.filters || {};\n      const filterConfigKeys = Object.keys(filterConfig);\n      const filterConfigUrlParams = Object.fromEntries(\n        filterConfigKeys.map(key => [\n          DASHBOARD_UI_FILTER_CONFIG_URL_PARAM_KEY[key],\n          filterConfig[key],\n        ]),\n      );\n\n      // Allow url query parameters from dashboardUiConfig.urlParams to override the ones from filterConfig\n      const urlParams = {\n        ...dashboardConfigUrlParams,\n        ...filterConfigUrlParams,\n        ...dashboardUiConfig?.urlParams,\n      };\n      const urlParamsString = Object.keys(urlParams).length\n        ? '?' + new URLSearchParams(urlParams).toString()\n        : '';\n\n      // set up the iframe's sandbox configuration\n      iframe.sandbox.add('allow-same-origin'); // needed for postMessage to work\n      iframe.sandbox.add('allow-scripts'); // obviously the iframe needs scripts\n      iframe.sandbox.add('allow-presentation'); // for fullscreen charts\n      iframe.sandbox.add('allow-downloads'); // for downloading charts as image\n      iframe.sandbox.add('allow-forms'); // for forms to submit\n      iframe.sandbox.add('allow-popups'); // for exporting charts as csv\n      // additional sandbox props\n      iframeSandboxExtras.forEach((key: string) => {\n        iframe.sandbox.add(key);\n      });\n      // force a specific refererPolicy to be used in the iframe request\n      if (referrerPolicy) {\n        iframe.referrerPolicy = referrerPolicy;\n      }\n\n      // add the event listener before setting src, to be 100% sure that we capture the load event\n      iframe.addEventListener('load', () => {\n        // MessageChannel allows us to send and receive messages smoothly between our window and the iframe\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API\n        const commsChannel = new MessageChannel();\n        const ourPort = commsChannel.port1;\n        const theirPort = commsChannel.port2;\n\n        // Send one of the message channel ports to the iframe to initialize embedded comms\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n        // we know the content window isn't null because we are in the load event handler.\n        iframe.contentWindow!.postMessage(\n          { type: IFRAME_COMMS_MESSAGE_TYPE, handshake: 'port transfer' },\n          supersetDomain,\n          [theirPort],\n        );\n        log('sent message channel to the iframe');\n\n        // return our port from the promise\n        resolve(\n          new Switchboard({\n            port: ourPort,\n            name: 'superset-embedded-sdk',\n            debug,\n          }),\n        );\n      });\n      iframe.src = `${supersetDomain}/embedded/${id}${urlParamsString}`;\n      iframe.title = iframeTitle;\n      //@ts-ignore\n      mountPoint.replaceChildren(iframe);\n      log('placed the iframe');\n    });\n  }\n\n  const [guestToken, ourPort]: [string, Switchboard] = await Promise.all([\n    fetchGuestToken(),\n    mountIframe(),\n  ]);\n\n  ourPort.emit('guestToken', { guestToken });\n  log('sent guest token');\n\n  async function refreshGuestToken() {\n    const newGuestToken = await fetchGuestToken();\n    ourPort.emit('guestToken', { guestToken: newGuestToken });\n    setTimeout(refreshGuestToken, getGuestTokenRefreshTiming(newGuestToken));\n  }\n\n  setTimeout(refreshGuestToken, getGuestTokenRefreshTiming(guestToken));\n\n  function unmount() {\n    log('unmounting');\n    //@ts-ignore\n    mountPoint.replaceChildren();\n  }\n\n  const getScrollSize = () => ourPort.get<Size>('getScrollSize');\n  const getDashboardPermalink = (anchor: string) =>\n    ourPort.get<string>('getDashboardPermalink', { anchor });\n  const getActiveTabs = () => ourPort.get<string[]>('getActiveTabs');\n  const getDataMask = () => ourPort.get<Record<string, any>>('getDataMask');\n  const observeDataMask = (\n    callbackFn: ObserveDataMaskCallbackFn,\n  ) => {\n    ourPort.start();\n    ourPort.defineMethod('observeDataMask', callbackFn);\n  };\n  // TODO: Add proper types once theming branch is merged\n  const setThemeConfig = async (themeConfig: Record<string, any>): Promise<void> => {\n    try {\n      ourPort.emit('setThemeConfig', { themeConfig });\n      log('Theme config sent successfully (or at least message dispatched)');\n    } catch (error) {\n      log(\n        'Error sending theme config. Ensure the iframe side implements the \"setThemeConfig\" method.',\n      );\n      throw error;\n    }\n  };\n\n  return {\n    getScrollSize,\n    unmount,\n    getDashboardPermalink,\n    getActiveTabs,\n    observeDataMask,\n    getDataMask,\n    setThemeConfig\n  };\n}\n"],
  "mappings": "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",
  "names": ["IFRAME_COMMS_MESSAGE_TYPE", "exports", "DASHBOARD_UI_FILTER_CONFIG_URL_PARAM_KEY", "visible", "expanded", "isGet", "message", "switchboardAction", "Actions", "GET", "isReply", "REPLY", "isEmit", "EMIT", "isError", "ERROR", "Switchboard", "constructor", "params", "port", "name", "methods", "incrementor", "debugMode", "isInitialised", "init", "logError", "debug", "addEventListener", "event", "log", "data", "postMessage", "getMethodResult", "method", "args", "executor", "messageId", "error", "result", "err", "defineMethod", "methodName", "get", "undefined", "Promise", "resolve", "reject", "Error", "getNewMessageId", "listener", "removeEventListener", "errStr", "start", "emit", "console", "Switchboard", "_jwtDecode", "require", "REFRESH_TIMING_BUFFER_MS", "exports", "MIN_REFRESH_WAIT_MS", "DEFAULT_TOKEN_EXP_MS", "getGuestTokenRefreshTiming", "currentGuestToken", "parsedJwt", "jwtDecode", "exp", "Date", "test", "parseFloat", "isValidDate", "toString", "ttl", "Math", "max", "getTime", "now", "_const", "require", "_switchboard", "_guestTokenRefresh", "embedDashboard", "id", "supersetDomain", "mountPoint", "fetchGuestToken", "dashboardUiConfig", "debug", "iframeTitle", "iframeSandboxExtras", "referrerPolicy", "log", "info", "console", "endsWith", "slice", "calculateConfig", "configNumber", "hideTitle", "hideTab", "hideChartControls", "emitDataMasks", "mountIframe", "Promise", "resolve", "iframe", "document", "createElement", "dashboardConfigUrlParams", "uiConfig", "undefined", "filterConfig", "filters", "filterConfigKeys", "Object", "keys", "filterConfigUrlParams", "fromEntries", "map", "key", "DASHBOARD_UI_FILTER_CONFIG_URL_PARAM_KEY", "urlParams", "urlParamsString", "length", "URLSearchParams", "toString", "sandbox", "add", "forEach", "addEventListener", "commsChannel", "MessageChannel", "ourPort", "port1", "theirPort", "port2", "contentWindow", "postMessage", "type", "IFRAME_COMMS_MESSAGE_TYPE", "handshake", "Switchboard", "port", "name", "src", "title", "replaceChildren", "guestToken", "all", "emit", "refreshGuestToken", "newGuestToken", "setTimeout", "getGuestTokenRefreshTiming", "unmount", "getScrollSize", "get", "getDashboardPermalink", "anchor", "getActiveTabs", "getDataMask", "observeDataMask", "callbackFn", "start", "defineMethod", "setThemeConfig", "themeConfig", "error"]
}
